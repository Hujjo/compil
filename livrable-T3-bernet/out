Buildfile: /home/ubuntu/workspace/livrable-T3-bernet/build.xml

init:

cup:
      [cup] This is CUP v0.11a beta 20060608
      [cup] Authors : Scott E. Hudson, Frank Flannery, Andrea Flexeder, Michael Petter and C. Scott Ananian
      [cup] Bugreports to petter@cs.tum.edu
      [cup] checking, whether this run is necessary
      [cup] Parserfile and symbolfile are existing
      [cup] Parserfile /home/ubuntu/workspace/livrable-T3-bernet/generate/jtiger/parser/parser.java isn't actual
      [cup] Symbolfile /home/ubuntu/workspace/livrable-T3-bernet/generate/jtiger/parser/sym.java isn't actual
      [cup] Warning : Terminal "ARRAY" was declared but never used
      [cup] Warning : Terminal "LOWPREC" was declared but never used
      [cup] Warning : Terminal "TYPE" was declared but never used
      [cup] Warning : Terminal "OF" was declared but never used
      [cup] Warning : Terminal "LBRACE" was declared but never used
      [cup] Warning : Terminal "RBRACE" was declared but never used
      [cup] Warning : *** Shift/Reduce conflict found in state #76
      [cup]   between dec ::= funcsDec (*) 
      [cup]   and     funcDec ::= (*) FUNCTION id LPAREN params RPAREN typeannotation EQ exp 
      [cup]   under symbol FUNCTION
      [cup]   Resolved in favor of shifting.
      [cup] 
      [cup] Warning : *** Shift/Reduce conflict found in state #120
      [cup]   between ifExp ::= IF exp THEN exp (*) 
      [cup]   and     ifExp ::= IF exp THEN exp (*) ELSE exp 
      [cup]   under symbol ELSE
      [cup]   Resolved in favor of shifting.
      [cup] 
      [cup] Error : *** More conflicts encountered than expected -- parser generation aborted
      [cup] ===== Terminals =====
      [cup] [0]EOF [1]error [2]COMMA [3]COLON [4]SEMICOLON 
      [cup] [5]LPAREN [6]RPAREN [7]LBRACK [8]RBRACK [9]LBRACE 
      [cup] [10]RBRACE [11]DOT [12]PLUS [13]MINUS [14]TIMES 
      [cup] [15]DIVIDE [16]EQ [17]NEQ [18]LT [19]LE 
      [cup] [20]GT [21]GE [22]AND [23]OR [24]ASSIGN 
      [cup] [25]ARRAY [26]IF [27]THEN [28]ELSE [29]WHILE 
      [cup] [30]FOR [31]TO [32]DO [33]LET [34]IN 
      [cup] [35]END [36]OF [37]BREAK [38]NIL [39]FUNCTION 
      [cup] [40]VAR [41]TYPE [42]ID [43]STRING [44]INT 
      [cup] [45]LOWPREC [46]UMINUS 
      [cup] 
      [cup] ===== Non terminals =====
      [cup] [0]exp [1]intExp [2]opExp [3]negExp [4]seqExp 
      [cup] [5]program [6]letExp [7]id [8]typeannotation [9]exps 
      [cup] [10]funcsDec [11]funcDec [12]decs [13]dec [14]varDec 
      [cup] [15]param [16]params [17]nilExp [18]stringExp [19]var 
      [cup] [20]simpleVar [21]recordVar [22]arrayVar [23]assignExp [24]arguments 
      [cup] [25]argument [26]callExp [27]breakExp [28]ifExp [29]whileExp 
      [cup] [30]forExp 
      [cup] 
      [cup] ===== Productions =====
      [cup] [0] $START ::= program EOF 
      [cup] [1] program ::= exp 
      [cup] [2] exp ::= intExp 
      [cup] [3] exp ::= opExp 
      [cup] [4] exp ::= negExp 
      [cup] [5] exp ::= seqExp 
      [cup] [6] exp ::= letExp 
      [cup] [7] exp ::= nilExp 
      [cup] [8] exp ::= stringExp 
      [cup] [9] exp ::= var 
      [cup] [10] exp ::= assignExp 
      [cup] [11] exp ::= callExp 
      [cup] [12] exp ::= breakExp 
      [cup] [13] exp ::= ifExp 
      [cup] [14] exp ::= whileExp 
      [cup] [15] exp ::= forExp 
      [cup] [16] intExp ::= INT 
      [cup] [17] opExp ::= exp PLUS exp 
      [cup] [18] opExp ::= exp MINUS exp 
      [cup] [19] opExp ::= exp TIMES exp 
      [cup] [20] opExp ::= exp DIVIDE exp 
      [cup] [21] opExp ::= exp EQ exp 
      [cup] [22] opExp ::= exp NEQ exp 
      [cup] [23] opExp ::= exp LT exp 
      [cup] [24] opExp ::= exp LE exp 
      [cup] [25] opExp ::= exp GT exp 
      [cup] [26] opExp ::= exp GE exp 
      [cup] [27] opExp ::= exp AND exp 
      [cup] [28] opExp ::= exp OR exp 
      [cup] [29] negExp ::= MINUS exp 
      [cup] [30] seqExp ::= LPAREN exps RPAREN 
      [cup] [31] seqExp ::= LPAREN RPAREN 
      [cup] [32] exps ::= exp 
      [cup] [33] exps ::= exps SEMICOLON exp 
      [cup] [34] letExp ::= LET decs IN exps END 
      [cup] [35] letExp ::= LET decs IN END 
      [cup] [36] decs ::= dec 
      [cup] [37] decs ::= decs dec 
      [cup] [38] dec ::= varDec 
      [cup] [39] dec ::= funcsDec 
      [cup] [40] varDec ::= VAR id typeannotation ASSIGN exp 
      [cup] [41] funcsDec ::= funcDec 
      [cup] [42] funcsDec ::= funcsDec funcDec 
      [cup] [43] funcDec ::= FUNCTION id LPAREN params RPAREN typeannotation EQ exp 
      [cup] [44] params ::= param 
      [cup] [45] params ::= params COMMA param 
      [cup] [46] param ::= id COLON id 
      [cup] [47] typeannotation ::= 
      [cup] [48] typeannotation ::= COLON id 
      [cup] [49] id ::= ID 
      [cup] [50] nilExp ::= NIL 
      [cup] [51] stringExp ::= STRING 
      [cup] [52] var ::= simpleVar 
      [cup] [53] var ::= arrayVar 
      [cup] [54] var ::= recordVar 
      [cup] [55] simpleVar ::= id 
      [cup] [56] arrayVar ::= var LBRACK exp RBRACK 
      [cup] [57] recordVar ::= var DOT id 
      [cup] [58] assignExp ::= var ASSIGN exp 
      [cup] [59] callExp ::= id LPAREN arguments RPAREN 
      [cup] [60] callExp ::= id LPAREN RPAREN 
      [cup] [61] arguments ::= argument 
      [cup] [62] arguments ::= arguments COMMA argument 
      [cup] [63] argument ::= exp 
      [cup] [64] breakExp ::= BREAK 
      [cup] [65] forExp ::= FOR id ASSIGN exp TO exp DO exp 
      [cup] [66] whileExp ::= WHILE exp DO exp 
      [cup] [67] ifExp ::= IF exp THEN exp 
      [cup] [68] ifExp ::= IF exp THEN exp ELSE exp 
      [cup] 
      [cup] ===== Viable Prefix Recognizer =====
      [cup] START lalr_state [0]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [nilExp ::= (*) NIL , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) whileExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) seqExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [simpleVar ::= (*) id , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) assignExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [program ::= (*) exp , {EOF }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [stringExp ::= (*) STRING , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) forExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) letExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) callExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) intExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) simpleVar , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [intExp ::= (*) INT , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) nilExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) breakExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) opExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) arrayVar , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) stringExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [id ::= (*) ID , {EOF LPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) ifExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) negExp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) recordVar , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) var , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [$START ::= (*) program EOF , {EOF }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on program to state [9]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [6]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [1]: {
      [cup]   [exp ::= stringExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [2]: {
      [cup]   [intExp ::= INT (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [3]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [nilExp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) whileExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) seqExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [breakExp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [simpleVar ::= (*) id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [opExp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) assignExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [stringExp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) forExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) letExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [negExp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) callExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) intExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [var ::= (*) simpleVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [intExp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) nilExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [whileExp ::= WHILE (*) exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [recordVar ::= (*) var DOT id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) breakExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) opExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [var ::= (*) arrayVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [letExp ::= (*) LET decs IN END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) stringExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [id ::= (*) ID , {LPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) ifExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) negExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [var ::= (*) recordVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [opExp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) var , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [123]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [4]: {
      [cup]   [var ::= simpleVar (*) , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [5]: {
      [cup]   [exp ::= callExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [6]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [program ::= exp (*) , {EOF }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [7]: {
      [cup]   [ifExp ::= IF (*) exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [nilExp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) whileExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) seqExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [breakExp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [simpleVar ::= (*) id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
      [cup]   [opExp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) assignExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [stringExp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) forExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) letExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
      [cup]   [negExp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) callExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) intExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [var ::= (*) simpleVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [intExp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) nilExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [recordVar ::= (*) var DOT id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) breakExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) opExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [var ::= (*) arrayVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
      [cup]   [letExp ::= (*) LET decs IN END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) stringExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [ifExp ::= IF (*) exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [id ::= (*) ID , {LPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) ifExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) negExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [var ::= (*) recordVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
      [cup]   [opExp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [exp ::= (*) var , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [118]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [8]: {
      [cup]   [exp ::= whileExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [9]: {
      [cup]   [$START ::= program (*) EOF , {EOF }]
      [cup] }
      [cup] transition on EOF to state [117]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [10]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [nilExp ::= (*) NIL , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exps ::= (*) exp , {SEMICOLON RPAREN }]
      [cup]   [opExp ::= (*) exp LT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) whileExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) seqExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [breakExp ::= (*) BREAK , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [simpleVar ::= (*) id , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp OR exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) assignExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [stringExp ::= (*) STRING , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exps ::= (*) exps SEMICOLON exp , {SEMICOLON RPAREN }]
      [cup]   [opExp ::= (*) exp LE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) forExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) letExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [negExp ::= (*) MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) callExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) intExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) simpleVar , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [intExp ::= (*) INT , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) nilExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [recordVar ::= (*) var DOT id , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= LPAREN (*) exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp EQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) breakExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) opExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) arrayVar , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN END , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) stringExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [id ::= (*) ID , {SEMICOLON LPAREN RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= LPAREN (*) RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) ifExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) negExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) recordVar , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp AND exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) var , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [97]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on RPAREN to state [115]
      [cup] transition on exps to state [114]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [11]: {
      [cup]   [nilExp ::= NIL (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [12]: {
      [cup]   [id ::= ID (*) , {EOF COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [13]: {
      [cup]   [exp ::= letExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [14]: {
      [cup]   [stringExp ::= STRING (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [15]: {
      [cup]   [exp ::= forExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [16]: {
      [cup]   [exp ::= assignExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [17]: {
      [cup]   [exp ::= ifExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [18]: {
      [cup]   [var ::= arrayVar (*) , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [19]: {
      [cup]   [callExp ::= id (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= id (*) LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= id (*) , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on LPAREN to state [106]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [20]: {
      [cup]   [breakExp ::= BREAK (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [21]: {
      [cup]   [exp ::= intExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [22]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= MINUS (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [105]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [23]: {
      [cup]   [funcDec ::= (*) FUNCTION id LPAREN params RPAREN typeannotation EQ exp , {IN FUNCTION VAR }]
      [cup]   [varDec ::= (*) VAR id typeannotation ASSIGN exp , {IN FUNCTION VAR }]
      [cup]   [letExp ::= LET (*) decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [decs ::= (*) decs dec , {IN FUNCTION VAR }]
      [cup]   [funcsDec ::= (*) funcsDec funcDec , {IN FUNCTION VAR }]
      [cup]   [dec ::= (*) funcsDec , {IN FUNCTION VAR }]
      [cup]   [decs ::= (*) dec , {IN FUNCTION VAR }]
      [cup]   [funcsDec ::= (*) funcDec , {IN FUNCTION VAR }]
      [cup]   [letExp ::= LET (*) decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [dec ::= (*) varDec , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on funcsDec to state [76]
      [cup] transition on dec to state [75]
      [cup] transition on FUNCTION to state [74]
      [cup] transition on varDec to state [73]
      [cup] transition on decs to state [72]
      [cup] transition on funcDec to state [71]
      [cup] transition on VAR to state [70]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [24]: {
      [cup]   [exp ::= negExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [25]: {
      [cup]   [exp ::= opExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [26]: {
      [cup]   [exp ::= breakExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [27]: {
      [cup]   [recordVar ::= var (*) DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= var (*) LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= var (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= var (*) ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on DOT to state [65]
      [cup] transition on ASSIGN to state [64]
      [cup] transition on LBRACK to state [63]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [28]: {
      [cup]   [id ::= (*) ID , {ASSIGN }]
      [cup]   [forExp ::= FOR (*) id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on id to state [32]
      [cup] transition on ID to state [12]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [29]: {
      [cup]   [var ::= recordVar (*) , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [30]: {
      [cup]   [exp ::= seqExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [31]: {
      [cup]   [exp ::= nilExp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [32]: {
      [cup]   [forExp ::= FOR id (*) ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on ASSIGN to state [33]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [33]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [nilExp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) whileExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) seqExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [breakExp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [simpleVar ::= (*) id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
      [cup]   [opExp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) assignExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [stringExp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) forExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) letExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [forExp ::= FOR id ASSIGN (*) exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
      [cup]   [negExp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) callExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) intExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [var ::= (*) simpleVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [intExp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) nilExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [recordVar ::= (*) var DOT id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) breakExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) opExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [var ::= (*) arrayVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
      [cup]   [letExp ::= (*) LET decs IN END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) stringExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [id ::= (*) ID , {LPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) ifExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) negExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [var ::= (*) recordVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
      [cup]   [opExp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [exp ::= (*) var , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [34]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [34]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [forExp ::= FOR id ASSIGN exp (*) TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on PLUS to state [42]
      [cup] transition on EQ to state [41]
      [cup] transition on NEQ to state [40]
      [cup] transition on TO to state [39]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [35]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp MINUS (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [62]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [36]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp AND (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [61]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [37]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp DIVIDE (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [60]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [38]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp GE (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [59]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [39]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [nilExp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) whileExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) seqExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [breakExp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [simpleVar ::= (*) id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [opExp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) assignExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [stringExp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [forExp ::= FOR id ASSIGN exp TO (*) exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) letExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [negExp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) callExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) intExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [var ::= (*) simpleVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [intExp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) nilExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [recordVar ::= (*) var DOT id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) breakExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) opExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [var ::= (*) arrayVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [letExp ::= (*) LET decs IN END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) stringExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [id ::= (*) ID , {LPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) ifExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) negExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [var ::= (*) recordVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
      [cup]   [opExp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [exp ::= (*) var , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [56]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [40]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp NEQ (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [55]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [41]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp EQ (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [54]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [42]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp PLUS (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [53]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [43]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp LE (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [52]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [44]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp GT (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [51]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [45]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp TIMES (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [50]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [46]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp LT (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [49]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [47]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp OR (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [48]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [48]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp OR exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [49]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp LT exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [50]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp TIMES exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [51]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp GT exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [52]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp LE exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [53]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp PLUS exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [54]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp EQ exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [55]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp NEQ exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [56]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [forExp ::= FOR id ASSIGN exp TO exp (*) DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on DO to state [57]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on PLUS to state [42]
      [cup] transition on EQ to state [41]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [57]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= FOR id ASSIGN exp TO exp DO (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [58]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [58]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= FOR id ASSIGN exp TO exp DO exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [59]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp GE exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [60]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp DIVIDE exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [61]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp AND exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [62]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp MINUS exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [63]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [nilExp ::= (*) NIL , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp LT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) whileExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) seqExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [breakExp ::= (*) BREAK , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [simpleVar ::= (*) id , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp OR exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) assignExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [stringExp ::= (*) STRING , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp LE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) forExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) letExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arrayVar ::= var LBRACK (*) exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [negExp ::= (*) MINUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) callExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) intExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) simpleVar , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [intExp ::= (*) INT , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) nilExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [recordVar ::= (*) var DOT id , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp EQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) breakExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) opExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) arrayVar , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN END , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) stringExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [id ::= (*) ID , {LPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) ifExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) negExp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) recordVar , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp AND exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) var , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [68]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [64]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= var ASSIGN (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [67]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [65]: {
      [cup]   [recordVar ::= var DOT (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on id to state [66]
      [cup] transition on ID to state [12]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [66]: {
      [cup]   [recordVar ::= var DOT id (*) , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [67]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= var ASSIGN exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [68]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) OR exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) GT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arrayVar ::= var LBRACK exp (*) RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) LE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) EQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) GE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) LT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on RBRACK to state [69]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on PLUS to state [42]
      [cup] transition on EQ to state [41]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [69]: {
      [cup]   [arrayVar ::= var LBRACK exp RBRACK (*) , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [70]: {
      [cup]   [id ::= (*) ID , {COLON ASSIGN }]
      [cup]   [varDec ::= VAR (*) id typeannotation ASSIGN exp , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on id to state [101]
      [cup] transition on ID to state [12]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [71]: {
      [cup]   [funcsDec ::= funcDec (*) , {IN FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [72]: {
      [cup]   [funcDec ::= (*) FUNCTION id LPAREN params RPAREN typeannotation EQ exp , {IN FUNCTION VAR }]
      [cup]   [letExp ::= LET decs (*) IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [decs ::= decs (*) dec , {IN FUNCTION VAR }]
      [cup]   [varDec ::= (*) VAR id typeannotation ASSIGN exp , {IN FUNCTION VAR }]
      [cup]   [funcsDec ::= (*) funcsDec funcDec , {IN FUNCTION VAR }]
      [cup]   [dec ::= (*) funcsDec , {IN FUNCTION VAR }]
      [cup]   [letExp ::= LET decs (*) IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [funcsDec ::= (*) funcDec , {IN FUNCTION VAR }]
      [cup]   [dec ::= (*) varDec , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on dec to state [94]
      [cup] transition on funcsDec to state [76]
      [cup] transition on FUNCTION to state [74]
      [cup] transition on varDec to state [73]
      [cup] transition on funcDec to state [71]
      [cup] transition on IN to state [93]
      [cup] transition on VAR to state [70]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [73]: {
      [cup]   [dec ::= varDec (*) , {IN FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [74]: {
      [cup]   [id ::= (*) ID , {LPAREN }]
      [cup]   [funcDec ::= FUNCTION (*) id LPAREN params RPAREN typeannotation EQ exp , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on id to state [78]
      [cup] transition on ID to state [12]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [75]: {
      [cup]   [decs ::= dec (*) , {IN FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [76]: {
      [cup]   [funcDec ::= (*) FUNCTION id LPAREN params RPAREN typeannotation EQ exp , {IN FUNCTION VAR }]
      [cup]   [funcsDec ::= funcsDec (*) funcDec , {IN FUNCTION VAR }]
      [cup]   [dec ::= funcsDec (*) , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on FUNCTION to state [74]
      [cup] transition on funcDec to state [77]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [77]: {
      [cup]   [funcsDec ::= funcsDec funcDec (*) , {IN FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [78]: {
      [cup]   [funcDec ::= FUNCTION id (*) LPAREN params RPAREN typeannotation EQ exp , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on LPAREN to state [79]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [79]: {
      [cup]   [funcDec ::= FUNCTION id LPAREN (*) params RPAREN typeannotation EQ exp , {IN FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {COLON }]
      [cup]   [param ::= (*) id COLON id , {COMMA RPAREN }]
      [cup]   [params ::= (*) params COMMA param , {COMMA RPAREN }]
      [cup]   [params ::= (*) param , {COMMA RPAREN }]
      [cup] }
      [cup] transition on id to state [82]
      [cup] transition on params to state [81]
      [cup] transition on param to state [80]
      [cup] transition on ID to state [12]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [80]: {
      [cup]   [params ::= param (*) , {COMMA RPAREN }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [81]: {
      [cup]   [params ::= params (*) COMMA param , {COMMA RPAREN }]
      [cup]   [funcDec ::= FUNCTION id LPAREN params (*) RPAREN typeannotation EQ exp , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on RPAREN to state [86]
      [cup] transition on COMMA to state [85]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [82]: {
      [cup]   [param ::= id (*) COLON id , {COMMA RPAREN }]
      [cup] }
      [cup] transition on COLON to state [83]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [83]: {
      [cup]   [param ::= id COLON (*) id , {COMMA RPAREN }]
      [cup]   [id ::= (*) ID , {COMMA RPAREN }]
      [cup] }
      [cup] transition on id to state [84]
      [cup] transition on ID to state [12]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [84]: {
      [cup]   [param ::= id COLON id (*) , {COMMA RPAREN }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [85]: {
      [cup]   [id ::= (*) ID , {COLON }]
      [cup]   [param ::= (*) id COLON id , {COMMA RPAREN }]
      [cup]   [params ::= params COMMA (*) param , {COMMA RPAREN }]
      [cup] }
      [cup] transition on id to state [82]
      [cup] transition on param to state [92]
      [cup] transition on ID to state [12]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [86]: {
      [cup]   [typeannotation ::= (*) COLON id , {EQ }]
      [cup]   [typeannotation ::= (*) , {EQ }]
      [cup]   [funcDec ::= FUNCTION id LPAREN params RPAREN (*) typeannotation EQ exp , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on COLON to state [88]
      [cup] transition on typeannotation to state [87]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [87]: {
      [cup]   [funcDec ::= FUNCTION id LPAREN params RPAREN typeannotation (*) EQ exp , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on EQ to state [90]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [88]: {
      [cup]   [id ::= (*) ID , {EQ ASSIGN }]
      [cup]   [typeannotation ::= COLON (*) id , {EQ ASSIGN }]
      [cup] }
      [cup] transition on id to state [89]
      [cup] transition on ID to state [12]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [89]: {
      [cup]   [typeannotation ::= COLON id (*) , {EQ ASSIGN }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [90]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [funcDec ::= FUNCTION id LPAREN params RPAREN typeannotation EQ (*) exp , {IN FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {LPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [91]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [91]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [funcDec ::= FUNCTION id LPAREN params RPAREN typeannotation EQ exp (*) , {IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [92]: {
      [cup]   [params ::= params COMMA param (*) , {COMMA RPAREN }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [93]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [nilExp ::= (*) NIL , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exps ::= (*) exp , {SEMICOLON END }]
      [cup]   [opExp ::= (*) exp LT exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) whileExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) seqExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [breakExp ::= (*) BREAK , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [simpleVar ::= (*) id , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [opExp ::= (*) exp OR exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp TIMES exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) assignExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [stringExp ::= (*) STRING , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exps ::= (*) exps SEMICOLON exp , {SEMICOLON END }]
      [cup]   [opExp ::= (*) exp LE exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) forExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) letExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [negExp ::= (*) MINUS exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) callExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) intExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [letExp ::= LET decs IN (*) exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp GT exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [intExp ::= (*) INT , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) nilExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [recordVar ::= (*) var DOT id , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp EQ exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) breakExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) opExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [letExp ::= LET decs IN (*) END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [letExp ::= (*) LET decs IN END , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp GE exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp PLUS exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) stringExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [id ::= (*) ID , {SEMICOLON LPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp NEQ exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) ifExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) negExp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [var ::= (*) recordVar , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [opExp ::= (*) exp AND exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp MINUS exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) var , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [97]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on END to state [96]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on exps to state [95]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [94]: {
      [cup]   [decs ::= decs dec (*) , {IN FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [95]: {
      [cup]   [letExp ::= LET decs IN exps (*) END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exps ::= exps (*) SEMICOLON exp , {SEMICOLON END }]
      [cup] }
      [cup] transition on END to state [99]
      [cup] transition on SEMICOLON to state [98]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [96]: {
      [cup]   [letExp ::= LET decs IN END (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [97]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) OR exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) GT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) NEQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) TIMES exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) AND exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) LE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) EQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exps ::= exp (*) , {SEMICOLON RPAREN END }]
      [cup]   [opExp ::= exp (*) GE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) LT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [98]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [nilExp ::= (*) NIL , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp LT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) whileExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) seqExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [breakExp ::= (*) BREAK , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [simpleVar ::= (*) id , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [opExp ::= (*) exp OR exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp TIMES exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) assignExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [stringExp ::= (*) STRING , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exps ::= exps SEMICOLON (*) exp , {SEMICOLON RPAREN END }]
      [cup]   [opExp ::= (*) exp LE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) forExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) letExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [negExp ::= (*) MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) callExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) intExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [var ::= (*) simpleVar , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp GT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [intExp ::= (*) INT , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) nilExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [recordVar ::= (*) var DOT id , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp EQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) breakExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) opExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [var ::= (*) arrayVar , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [letExp ::= (*) LET decs IN END , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp GE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp PLUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) stringExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [id ::= (*) ID , {SEMICOLON LPAREN RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp NEQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) ifExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) negExp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [var ::= (*) recordVar , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
      [cup]   [opExp ::= (*) exp AND exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= (*) exp MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exp ::= (*) var , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [100]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [99]: {
      [cup]   [letExp ::= LET decs IN exps END (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [100]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) OR exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) GT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) NEQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) TIMES exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [exps ::= exps SEMICOLON exp (*) , {SEMICOLON RPAREN END }]
      [cup]   [opExp ::= exp (*) AND exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) LE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) EQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) GE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) LT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [101]: {
      [cup]   [varDec ::= VAR id (*) typeannotation ASSIGN exp , {IN FUNCTION VAR }]
      [cup]   [typeannotation ::= (*) COLON id , {ASSIGN }]
      [cup]   [typeannotation ::= (*) , {ASSIGN }]
      [cup] }
      [cup] transition on COLON to state [88]
      [cup] transition on typeannotation to state [102]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [102]: {
      [cup]   [varDec ::= VAR id typeannotation (*) ASSIGN exp , {IN FUNCTION VAR }]
      [cup] }
      [cup] transition on ASSIGN to state [103]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [103]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [varDec ::= VAR id typeannotation ASSIGN (*) exp , {IN FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {LPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [104]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [104]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [varDec ::= VAR id typeannotation ASSIGN exp (*) , {IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [105]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= MINUS exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [106]: {
      [cup]   [callExp ::= id LPAREN (*) arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [nilExp ::= (*) NIL , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp LT exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) whileExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) seqExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [breakExp ::= (*) BREAK , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [simpleVar ::= (*) id , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp OR exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) assignExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [callExp ::= id LPAREN (*) RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [stringExp ::= (*) STRING , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp LE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) forExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) letExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [negExp ::= (*) MINUS exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) callExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) intExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arguments ::= (*) argument , {COMMA RPAREN }]
      [cup]   [var ::= (*) simpleVar , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GT exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [intExp ::= (*) INT , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) nilExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [recordVar ::= (*) var DOT id , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp EQ exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) breakExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) opExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arguments ::= (*) arguments COMMA argument , {COMMA RPAREN }]
      [cup]   [var ::= (*) arrayVar , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN END , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) stringExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [id ::= (*) ID , {COMMA LPAREN RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) ifExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) negExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [argument ::= (*) exp , {COMMA RPAREN }]
      [cup]   [var ::= (*) recordVar , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp AND exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) var , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on arguments to state [110]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on BREAK to state [20]
      [cup] transition on intExp to state [21]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on argument to state [109]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [108]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on RPAREN to state [107]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [107]: {
      [cup]   [callExp ::= id LPAREN RPAREN (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [108]: {
      [cup]   [argument ::= exp (*) , {COMMA RPAREN }]
      [cup]   [opExp ::= exp (*) PLUS exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) OR exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) GT exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) AND exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) LE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) EQ exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) GE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) LT exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [109]: {
      [cup]   [arguments ::= argument (*) , {COMMA RPAREN }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [110]: {
      [cup]   [callExp ::= id LPAREN arguments (*) RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arguments ::= arguments (*) COMMA argument , {COMMA RPAREN }]
      [cup] }
      [cup] transition on RPAREN to state [112]
      [cup] transition on COMMA to state [111]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [111]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [nilExp ::= (*) NIL , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp LT exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) whileExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) seqExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [breakExp ::= (*) BREAK , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [simpleVar ::= (*) id , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp OR exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) assignExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [stringExp ::= (*) STRING , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp LE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) forExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) letExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [negExp ::= (*) MINUS exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) callExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) intExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [var ::= (*) simpleVar , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GT exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [intExp ::= (*) INT , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) nilExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [recordVar ::= (*) var DOT id , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp EQ exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) breakExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) opExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [arguments ::= arguments COMMA (*) argument , {COMMA RPAREN }]
      [cup]   [var ::= (*) arrayVar , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [letExp ::= (*) LET decs IN END , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp GE exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) stringExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [id ::= (*) ID , {COMMA LPAREN RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) ifExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) negExp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [argument ::= (*) exp , {COMMA RPAREN }]
      [cup]   [var ::= (*) recordVar , {COMMA RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
      [cup]   [opExp ::= (*) exp AND exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup]   [exp ::= (*) var , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on argument to state [113]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [108]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [112]: {
      [cup]   [callExp ::= id LPAREN arguments RPAREN (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [113]: {
      [cup]   [arguments ::= arguments COMMA argument (*) , {COMMA RPAREN }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [114]: {
      [cup]   [seqExp ::= LPAREN exps (*) RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exps ::= exps (*) SEMICOLON exp , {SEMICOLON RPAREN }]
      [cup] }
      [cup] transition on RPAREN to state [116]
      [cup] transition on SEMICOLON to state [98]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [115]: {
      [cup]   [seqExp ::= LPAREN RPAREN (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [116]: {
      [cup]   [seqExp ::= LPAREN exps RPAREN (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [117]: {
      [cup]   [$START ::= program EOF (*) , {EOF }]
      [cup] }
      [cup] 
      [cup] -------------------
      [cup] lalr_state [118]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [ifExp ::= IF exp (*) THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [ifExp ::= IF exp (*) THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on PLUS to state [42]
      [cup] transition on EQ to state [41]
      [cup] transition on NEQ to state [40]
      [cup] transition on THEN to state [119]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [119]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= IF exp THEN (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= IF exp THEN (*) exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [120]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [120]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= IF exp THEN exp (*) ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= IF exp THEN exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on ELSE to state [121]
      [cup] transition on LE to state [43]
      [cup] transition on PLUS to state [42]
      [cup] transition on EQ to state [41]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [121]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= IF exp THEN exp ELSE (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [122]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [122]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= IF exp THEN exp ELSE exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [123]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [whileExp ::= WHILE exp (*) DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on DO to state [124]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [124]: {
      [cup]   [ifExp ::= (*) IF exp THEN exp ELSE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN arguments RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [nilExp ::= (*) NIL , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) whileExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) seqExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [breakExp ::= (*) BREAK , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [simpleVar ::= (*) id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) assignExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [callExp ::= (*) id LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [stringExp ::= (*) STRING , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) forExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) letExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [forExp ::= (*) FOR id ASSIGN exp TO exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [arrayVar ::= (*) var LBRACK exp RBRACK , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [negExp ::= (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) callExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) intExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) simpleVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN exps END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [intExp ::= (*) INT , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) nilExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= WHILE exp DO (*) exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= (*) WHILE exp DO exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [recordVar ::= (*) var DOT id , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN exps RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) breakExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) opExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) arrayVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [letExp ::= (*) LET decs IN END , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) stringExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [ifExp ::= (*) IF exp THEN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [assignExp ::= (*) var ASSIGN exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [id ::= (*) ID , {EOF COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [seqExp ::= (*) LPAREN RPAREN , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) ifExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) negExp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [var ::= (*) recordVar , {EOF COMMA SEMICOLON RPAREN LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= (*) exp MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [exp ::= (*) var , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on nilExp to state [31]
      [cup] transition on seqExp to state [30]
      [cup] transition on recordVar to state [29]
      [cup] transition on FOR to state [28]
      [cup] transition on var to state [27]
      [cup] transition on breakExp to state [26]
      [cup] transition on opExp to state [25]
      [cup] transition on negExp to state [24]
      [cup] transition on LET to state [23]
      [cup] transition on MINUS to state [22]
      [cup] transition on intExp to state [21]
      [cup] transition on BREAK to state [20]
      [cup] transition on id to state [19]
      [cup] transition on arrayVar to state [18]
      [cup] transition on ifExp to state [17]
      [cup] transition on assignExp to state [16]
      [cup] transition on forExp to state [15]
      [cup] transition on STRING to state [14]
      [cup] transition on letExp to state [13]
      [cup] transition on ID to state [12]
      [cup] transition on NIL to state [11]
      [cup] transition on LPAREN to state [10]
      [cup] transition on whileExp to state [8]
      [cup] transition on IF to state [7]
      [cup] transition on exp to state [125]
      [cup] transition on callExp to state [5]
      [cup] transition on simpleVar to state [4]
      [cup] transition on WHILE to state [3]
      [cup] transition on INT to state [2]
      [cup] transition on stringExp to state [1]
      [cup] 
      [cup] -------------------
      [cup] lalr_state [125]: {
      [cup]   [opExp ::= exp (*) PLUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) OR exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) NEQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) TIMES exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) AND exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) EQ exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) MINUS exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [whileExp ::= WHILE exp DO exp (*) , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) GE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) LT exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup]   [opExp ::= exp (*) DIVIDE exp , {EOF COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR }]
      [cup] }
      [cup] transition on OR to state [47]
      [cup] transition on LT to state [46]
      [cup] transition on TIMES to state [45]
      [cup] transition on GT to state [44]
      [cup] transition on LE to state [43]
      [cup] transition on EQ to state [41]
      [cup] transition on PLUS to state [42]
      [cup] transition on NEQ to state [40]
      [cup] transition on GE to state [38]
      [cup] transition on DIVIDE to state [37]
      [cup] transition on AND to state [36]
      [cup] transition on MINUS to state [35]
      [cup] 
      [cup] -------------------
      [cup] ------- CUP v0.11a beta 20060608 Parser Generation Summary -------
      [cup]   1 error and 8 warnings
      [cup]   47 terminals, 31 non-terminals, and 69 productions declared, 
      [cup]   producing 126 unique parse states.
      [cup]   6 terminals declared but not used.
      [cup]   0 non-terminals declared but not used.
      [cup]   0 productions never reduced.
      [cup]   2 conflicts detected (1 expected).
      [cup]   No code produced.
      [cup] ---------------------------------------------------- (v0.11a beta 20060608)
